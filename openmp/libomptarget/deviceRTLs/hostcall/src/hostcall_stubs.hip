///
///  hostcall_stubs.hip
///

#include "../../../src/hostrpc_service_id.h"
#include "hostcall_stubs.h"
// -----------------------------------------------------------------------------
//
// printf: stubs to support printf 
//
// GPUs typically do not support vaargs style functions.  So to implement
// printf or any vaargs function as a hostcall service requires the compiler 
// to generate code to allocate a buffer, fill the buffer with the value of
// each argument, and then call a stub to execute the service with a pointer to 
// the buffer. The clang compiler does this in the CGGPUBuiltin.cpp source.
// Here we define printf_allocate and printf_execute device functions that are
// generated by the clang compiler when it encounters a printf statement.
// printf_allocate is implemented as a hostcall stub. We assume that the 
// host routine for printf_execute will free the buffer that was allocated
// by printf_allocate.

// These 4 stubs all use the same MALLOC SERVICE routine
EXTERN char * printf_allocate(uint32_t bufsz) {
  uint64_t arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7;
  arg0 = (uint64_t) bufsz;
  hostcall_result_t result = hostcall_invoke(PACK_VERS(HOSTCALL_SERVICE_MALLOC),
    arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  __builtin_amdgcn_wave_barrier();
  return (char *) result.arg1;
}
EXTERN char * hostrpc_varfn_uint_allocate(uint32_t bufsz) {
  uint64_t arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7;
  arg0 = (uint64_t) bufsz;
  hostcall_result_t result = hostcall_invoke(PACK_VERS(HOSTCALL_SERVICE_MALLOC),
    arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  __builtin_amdgcn_wave_barrier();
  return (char *) result.arg1;
}
EXTERN char * hostrpc_varfn_uint64_allocate(uint32_t bufsz) {
  uint64_t arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7;
  arg0 = (uint64_t) bufsz;
  hostcall_result_t result = hostcall_invoke(PACK_VERS(HOSTCALL_SERVICE_MALLOC),
    arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  __builtin_amdgcn_wave_barrier();
  return (char *) result.arg1;
}
EXTERN char * hostrpc_varfn_double_allocate(uint32_t bufsz) {
  uint64_t arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7;
  arg0 = (uint64_t) bufsz;
  hostcall_result_t result = hostcall_invoke(PACK_VERS(HOSTCALL_SERVICE_MALLOC),
    arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  __builtin_amdgcn_wave_barrier();
  return (char *) result.arg1;
}

EXTERN void hostrpc_fptr0(void* fptr) {
  uint64_t arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7;
  arg0 = (uint64_t) fptr;
  hostcall_result_t result = hostcall_invoke(PACK_VERS(HOSTCALL_SERVICE_FUNCTIONCALL),
    arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);
}

EXTERN int printf_execute(char * print_buffer, uint32_t bufsz) { 
  uint64_t arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7;
  __builtin_amdgcn_wave_barrier();
  arg0 = (uint64_t) bufsz;
  arg1 = (uint64_t) print_buffer ;
  hostcall_result_t result = hostcall_invoke(PACK_VERS(HOSTCALL_SERVICE_PRINTF),
    arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  return (int) result.arg0;
}

EXTERN uint32_t hostrpc_varfn_uint_execute(char * print_buffer, uint32_t bufsz) { 
  uint64_t arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7;
  __builtin_amdgcn_wave_barrier();
  arg0 = (uint64_t) bufsz;
  arg1 = (uint64_t) print_buffer ;
  hostcall_result_t result = hostcall_invoke(PACK_VERS(HOSTCALL_SERVICE_VARFNUINT),
    arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  return (int) result.arg0;
}
EXTERN uint64_t hostrpc_varfn_uint64_execute(char * print_buffer, uint32_t bufsz) { 
  uint64_t arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7;
  __builtin_amdgcn_wave_barrier();
  arg0 = (uint64_t) bufsz;
  arg1 = (uint64_t) print_buffer ;
  hostcall_result_t result = hostcall_invoke(PACK_VERS(HOSTCALL_SERVICE_VARFNUINT64),
    arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  return (uint64_t) result.arg0;
}
EXTERN double hostrpc_varfn_double_execute(char * print_buffer, uint32_t bufsz) { 
  uint64_t arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7;
  __builtin_amdgcn_wave_barrier();
  arg0 = (uint64_t) bufsz;
  arg1 = (uint64_t) print_buffer ;
  hostcall_result_t result = hostcall_invoke(PACK_VERS(HOSTCALL_SERVICE_VARFNDOUBLE),
    arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  union { uint64_t val; double dval;} unionarg;
  unionarg.val = result.arg0;
  return unionarg.dval;
}

// This utility is used for printf arguments that are variable length strings
// The clang compiler will generate calls to this only when a string length is 
// not a compile time constant.
EXTERN uint32_t __strlen_max(char *instr, uint32_t maxstrlen) {
  for (uint32_t i = 0; i < maxstrlen ; i++)
    if (instr[i] == (char) 0 )
       return (uint32_t) (i+1);
  return maxstrlen;
}

// -----------------------------------------------------------------------------
//
// vector_product_zeros: Example stub to demonstrate hostcall services
//
// This is an example hostcall stub for a service called vector_product_zeros.
// This function calculates C = A*B and returns the number of zeros.
// Naturally, one would typically do this type of operation on a GPU. 
// But this is a demo  to illustrate the use of hostcall to run a service
// on the host.  The host service for HOSTCALL_SERVICE_DEMO is in 
//        aomp-extras/hostcall/lib/src/hostall_handlers.c 
// After copying the vectors from the GPU it calls this routine
// on the host. 
//
// int vector_product_zeros(int N, int*A, int*B, int*C) {
//    int zeros = 0;   
//    for (int i =0 ; i<N; i++) {
//       C[i] = A[i] * B[i];
//       if ( C[i] == 0  )
//          zeros++ ;
//    }
//    return zeros;
// }
//

EXTERN int vector_product_zeros(int N, int*A,  int*B, int*C) {
  uint64_t arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7;
  arg0 = (int64_t) N;
  // Pass these pointers to the host for memcpy
  arg1 = (int64_t) A;
  arg2 = (int64_t) B;
  arg3 = (int64_t) C;
  hostcall_result_t result = hostcall_invoke(PACK_VERS(HOSTCALL_SERVICE_DEMO),
    arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  int num_zeros = (int) result.arg1;
  return num_zeros;
}
